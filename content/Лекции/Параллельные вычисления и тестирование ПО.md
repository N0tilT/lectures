*Артёмов Игорь Юрьевич*

Программа - машинный код выполняющийся на ЦП  
Процесс - запущенная программа. Ничего не делает сам по себе. Кусок памяти, в который загружена программа, статические ресурсы (переменные)  
Чтобы процесс начал что-то делать, в нём запускается поток (как минимум 1)  

Методика карусельного типа параллельного выполнения процессов

Квант времени ОС - минимальный временной интервал, дающийся потоку для выполнения. ОООчень мало  
Приоритет процесса - от 0(низкий) до 10(высокий). По умолчанию у всех 5  

Idle - режим ожидания. Сетевые, файловые операции, действия пользователя на UI

Указание на каком CPU будет выполняться процесс

Потоки - на ОС, потоки в пространстве пользователя  
При работе с потоками, нет взаимодействия с ядром  

API:

1. POSIX API
2. Win32 API

i. Создание потоков - параметры: (callback - функция, которая будет выполняться в новом потоке) | pthread_create // CreateThread  
ii. Ждать, пока поток завершиться | pthread_join  

Механизмы атомарности операций

1. блокировки или мьютексы (mutex)
2. симафоры (semaphore) - блокировка снимаетcя, когда ресурсы становятся доступными

Файловые и сетевые операции желательно делать последовательными

  

Создание потока - подаёт только команду на запуск, а не запускает

```C
для компиляции: gcc ... -pthread ...

\#include <pthread.h>

pthread_create(
	pthread_t *thread, //поток
	const pthread_attr_t *attr, //атрибуты
	void *(*start_routine) (void *), //функция, которая будет вызываться в потоке callback
	void *arg //аргументы функции
)
//Пример колбэка
void * my_func (void * arg) {return NULL}
```

  

Запуск потока

```C
int pthread_join(
	pthread_t thread, //Указатель на поток
	void **retval     //Указатель на результат работы функции
)
```

  

Пример кода

```C
\#include <pthread.h>
\#include <stdio.h>

const static int _count = 100;

void * my_func(void *arg)
{
	int sum = 0, *xx = (int *)arg;
	
	for(int i = 0; i<_count; i++)
	{
		sum += xx[i];
	}

	return (void *)sum;
}

int main()
{
	int ar[_count], result = 0;
	pthread_t a1;

	for(int i = 0; i<_count; i++)
	{
		ar[i] = 1234*(i+67);
	}

	pthread_create(&a1,NULL, my_func, (void *) ar);
	pthread_join(a1, (void *) &result);
	print("%d\n", result);
	return 0;
}
```

  

  

Главная проблема асинхронного программирования - установка синхронного доступа к данным

Самое простое и часто использование решение - мьютексы (блокировки)

Блок на ресурс, пока не закончится работа с ним.

mutex.lock() и mutex.unlock()

  

```C
//При такой реализации можно работать с несколькими потоками, обьявив мютекс глобально
int pthread_mutex_init(
				pthread_mutex_t * restrict mutex, 
				const pthread_mutexattr_t *restrict attr
);  

//Или
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

//Освободить память для мьютекса
int pthread_mutex_destroy(pthread_mutex_t *mutex)
```

  

- lock - блокировка
- trylock - попробовать заблокировать
- unlock - разблокировка

  

```C
void foo(){
	pthread_mutex_lock(&foo_mutex);
	/* Do work СИНХРОННО*/
	pthread_mutex_unlock(&foo_mutex);
}
```

  

  

Семафор - инструмент для информирования потоков о свободном ресурсе. Реализованы на уровне ОС

wait() - ждём и post() - говорим, что нужно что-то делать

В wait мы ждём, пока не появится свободный ресурс

  

```C
\#include <semaphore.h>

//неименованные - для работы внутри потока. Быстрее, чем именованные
int sem_init(sem_t *sem, int pshared, unsigned int value);

sem_wait()
sem_trywait()
sem_timedwait() //Выполнение периодических действий, Все потоки в wait
```

  

На серверном приложении сделать не чтобы через fork() а через потоки

Создать программу для сервера, которая будет осуществлять нагрузочное тестирование (кол-во клиентов на время отклика)

  

Можно использовать вместо симафора (может быть чутьчтуь быстрее, чем симафор)

```C
pthread_cond_wait(pthread_cond_t cond, pthread_mutex_t *restrict mutex)
```

  

SQL запросы формируются на клиенте

Избегаем! Потому что -

скрываем детали, универсальность используемых компонентов

СУБД ограничено по количеству подключенных клиентов

malloc может вернуть null!

  

Презентация не раскрыла сильные стороны (

Описание взаимодействия клиента и сервера! - интерфейс взаимодействия

Не игнорируем картинки интерфейса, но не забываем про взаимодействие

  

Пояснительная записка 60 страниц 0-0

Теория - как мы любим языки программирования и БД :) Описание предметной области

  

Как работает - схемы, скриншоты, небольшие вставки кода

сшит колечками и маленькой упаковкой

  

3 бумажки - не должны быть головной болью

1. результаты проверки на антиплагиат третьей части
2. отзыв руководителя
3. рецензия из внешнего источника с печатью и подписью

  

Сетевые протоколы

  

RFC - request for commentary

  

SMTP/POP3/IMAP - почтовые протоколы

MTA - отправка почты

MDA - периодически опрашивает MTA с вопросом есть ли новая почта и доставляет её

  

  

SMTP - 25/TCP порт. Текстовый протокол из двух частей: запроса и ответа

После запроса могут идти параметры опциональные через пробел

ответ: 3 цифры пробел Текстовое описание ответа

  

коды ответов:

2 - успех

3 - требуются доп данные

4 - проблема со стороны клиента

5 - проблема со стороны сервера

  

следующие 2 цифры характеризуют ответы

  

запрос максимум из 4 букв

Начало работы  
HELO - стандарт + логин  

EHLO - расширенный протокол SMTP + логин

  

Шифрование данных SSL раньше, сейчас TLS(transport level security, v1.3)

1. шифруется всё (https)
2. шифруется только то, что скажет клиент - явный TLS

  

ответ: то, что сервер может делать

  

AUTH PLAIN <NULL>login<NULL>passwd

  

AUTH LOGIN

3xx login

login→base64

3xx password

password→base64

  

MAIL FROM

MAIL TO  
DATA  

Само письмо

  

  

Само письмо в формате MIME

шапка с метаданными + само сообщение в конце отправляем “.\n”